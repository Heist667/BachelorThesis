var geometry = 
    /* color: #0b4a8b */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[7.386253865527146, 52.31199041445132],
          [7.386253865527146, 52.211967941333526],
          [7.60289052324199, 52.211967941333526],
          [7.60289052324199, 52.31199041445132]]], null, false),
    imageCollection = ee.ImageCollection("COPERNICUS/S1_GRD"),
    imageCollection2 = ee.ImageCollection("GOOGLE/DYNAMICWORLD/V1");

Map.centerObject(geometry); //focus on the region of interest by using a polygon (to find in the import)
                            // select the ImageCollection COPERNICUS/S1_GRD 
  
  
var time_start = ee.Date('2023-10-01') //beginning of the heavy rain fall in the region of Rheine
var time_end = ee.Date('2024-02-29')   //mentioned ending of the flood in NRW and also for Rheine
var time_dif = time_end.difference(time_start, 'day') //select day as time unit

print(time_dif)

var sen1 = imageCollection
.filterDate(time_start, time_end) //limit of the time period
.filterBounds(geometry) //help to bond satellite data to the selected region of interest
.filter(ee.Filter.listContains('transmitterReceiverPolarisation','VV')) //only for Sentinel-1: transmitter receiver polarisation equals to VV
.filter(ee.Filter.eq('instrumentMode','IW')).select('VV') //select only such days with data with 'VV'


print(sen1.aggregate_array('orbitProperties_pass').distinct()) // including descending and ascending data


var asc = sen1
.filter(ee.Filter.eq('orbitProperties_pass','ASCENDING'))

var des = sen1
.filter(ee.Filter.eq('orbitProperties_pass','DESCENDING'))


var list_dates = ee.List.sequence(0, time_dif, 10).map(function(interval){ //difference of 10 days to improve the quality of data
  return ee.Date.fromYMD(2023, 10, 01).advance(interval, 'days') //beginning of the intervall with the used time unit
})

var asc_10days = ee.ImageCollection(list_dates.map(function(dates){   
  var start_date = ee.Date(dates)                                     
  var end_date = start_date.advance(10, 'days')
  var composite = asc.filterDate(start_date, end_date).mean()         //creating a composite for the average of all data by using 'mean'
  var bands = composite.bandNames().size()
  return composite
  .set('system:time_start', start_date.millis())
  .set('system:time_end', end_date.millis())
  .set('band_number', bands)                             //excluding such data where a band of VV = 0
})).filter(ee.Filter.eq('band_number',1));               // ...  

var des_10days = ee.ImageCollection(list_dates.map(function(dates){ 
  var start_date = ee.Date(dates)
  var end_date = start_date.advance(10, 'days')
  var composite = des.filterDate(start_date, end_date).mean() //creating a composite for the average of all data by using 'mean'
  var bands = composite.bandNames().size()
  return composite
  .set('system:time_start', start_date.millis())
  .set('system:time_end', end_date.millis())
  .set('band_number', bands)                             //excluding such data where a band of VV = 0
})).filter(ee.Filter.eq('band_number',1));               // ...  

var asc_sigma = asc_10days.map(function(img){                      //take the created data above
  var sigma = ee.Image(10).pow(img.divide(10)).rename('sigma')     // use of the formula of the paper to calculate the SSM
  var speckel = sigma.focalMean(30, 'square', 'meters');           // reduce speckel impact; 30 the right value?        
  return speckel
  .copyProperties(img, img.propertyNames())                        
  });
  
var des_sigma = des_10days.map(function(img){                     // take the created data above
  var sigma = ee.Image(10).pow(img.divide(10)).rename('sigma')    // ...
  var speckel = sigma.focalMean(30, 'square', 'meters');          // ...
  return speckel
  .copyProperties(img, img.propertyNames())
  });

//  When importing Dynamic World V1, references the land cover of the region of interest
var water_mask = imageCollection2.select('label')                 // create a mask for the water regions on the map and select the band 'label' (Index of the band with the highest estimated probability)
.filterDate(time_start, time_end)                                 // ... for the chosen time period; use of 'mode' (most frequent classes designed to each pixel) for unique / integrated landcover
.filterBounds(geometry).mode().eq(0).not()                        // selected the value '0' (precise description in the import 'Dynamic World V1')
                                                                  // => Estimated probability of complete coverage by water

var urban_mask = imageCollection2.select('label')                 // create a mask for the urban regions on the map and select ...
.filterDate(time_start, time_end)                                 // ...
.filterBounds(geometry).mode().eq(6).not()                        // selected the value '6' ... 
                                                                  // => Estimated probability of complete coverage by built
// in the masks, the pixel with the value of 0 are selected 


var asc_min = asc_sigma.min() // defining the minimum sigma value for each ascending image
var asc_max = asc_sigma.max() // ...          maximum ...

var asc_sm = asc_sigma.map(function(img){                               // starting the loop of calculation
  var index = (img.subtract(asc_min)).divide(asc_max.subtract(asc_min)) // division / subtraction as defined in the formula
  var date = img.date().format('YYYY-MM-dd')                            // allocation of the dates next to the bands name for each image
  return index.multiply(water_mask).multiply(urban_mask).rename('sm_asc') //combination of the two masks for the ascending data, multiply the values of
                                                                          // of water and urban masks
  .copyProperties(img, ['system:time_start'])
  .set('date', ee.String(date))                                           
  })
  
// visualization on the map with the time period for the Ems flooding
Map.addLayer(asc_sm.filterDate('2023-10-01','2024-02-29').toBands().clip(geometry),[],'sm_asc',false) // false helps to avoid automatic visualization
                                                                                                      // create the visualization for the time period and region of interest

print(asc_sm)

print(
  ui.Chart.image.series(asc_sm, geometry, ee.Reducer.mean(), 100, 'system:time_start') // creating a chart for ascending data that shows the soil moisture evolution 
                                                                                       // evolution during the time period
  )
  
var des_min = des_sigma.min() // defining the minimum sigma value for each descending image
var des_max = des_sigma.max() // ...          maximum ...

var des_sm = des_sigma.map(function(img){                                 //...
  var index = (img.subtract(des_min)).divide(des_max.subtract(des_min))   //...
  var date = img.date().format('YYYY-MM-dd')
  return index.multiply(water_mask).multiply(urban_mask).rename('sm_des') // ... for the descending data, ...
  .copyProperties(img, ['system:time_start'])                             // ...
  .set('date', ee.String(date))
  })

Map.addLayer(des_sm.filterDate('2023-10-01','2024-02-29').toBands().clip(geometry),[],'sm_des',false) // ...
                                                                                                      // ...
print(
  ui.Chart.image.series(des_sm, geometry, ee.Reducer.mean(), 100, 'system:time_start') // ... descending data that shows the soil moisture evolution 
  )                                                                                    // evolution during the time period

// adjusting the layers for ascending and descending layers on 1 band (Grayscale) and Stretch: 90%, then 'Apply'


Export.image.toDrive({ //exporting imaga to local storage
  image: des_sm.filterDate('2023-10-01','2024-02-29').toBands().clip(geometry), // used period related to the area of interest
  scale: 100,
  region: geometry,
  crs: 'EPSG:4326', // common code for the geographical coordinate system WGS 84
  folder:'test',
  maxPixels:1e13
  })
  
  // brighter sections show higer soil moisure, darker sections lower
